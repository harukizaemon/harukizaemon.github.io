---
layout: post
title: "Web standards and all I got was this lousy website"
alias: /2009/04/web-standards-and-all-i-got-was-this.html
categories:
---
Over the Easter long weekend, I had a great break from work and a great opportunity to think about and reflect on my career, my job, and my profession as a whole. It's safe to say I become a bit disheartened and disillusioned. The one striking conclusion I kept arriving at is that we are so technology focused that we spend too much time, money and effort building things that the customer is "happy" with but not blown away by. That we artificially constrain the end user experience based on our notions of "correctness".  In particular, **web application development is largely a bunch of dick-pulling technical masturbation**, forever re-inventing the wheel at a ridiculously low level of
abstraction shoving our technological solutions down user's throats in the name of "software engineering". **What's worse is that I've been complicit.** Not only by buying the hype but often by trying to do "the right thing" even when I felt as though I was bashing my head against a brick wall.

Rewind the clock to somewhere between 1996 and 1999. During those years I, along with a good friend and colleague built a desktop application that was delivered to thousands of users across Australia using nothing more than good old-fashioned client-server SQL written in, of all things, PowerBuilder -- kinda like VisualBasic. **More than 10 years ago, the user experience was compelling and sophisticated, it performed exceptionally well over 2400 baud dialup modems, and we built the initial release with only 2 people over 3 months from scratch.** As shameful as it is, especially coming from one so vocal about automated testing as I, we had nothing but manual testing but we also had few bugs and when users did find a problem, we fixed and redeployed within 24 hours -- mostly because we didn't want to interrupt users as they worked and so waited until after hours. Over the next 12 months, we were able to adapt to the user's needs immediately. Rarely did we add the features as request but we always managed to produce a solution they actually needed. Fast forward a decade and **I feel like I suck** because I honestly don't believe I could do the same thing again today. In fact, **I challenge any of us to build the same user experience with our existing technology stack**.

To those that know me well, I will no doubt sound like a broken record but I can't help feel we've been trying to coerce HTML & CSS into something they just aren't and doing so for a decade now.

Think about it, HTML: HyperText Markup Language. Does that sound like it has anything to do with layout and design? In fact do you know any designers, even those that call themselves web designers, that do any of their design work in HTML/CSS? No -- well none that I've ever heard of. The closest I can think of is a colleague who does his wireframes in OmniGraffle and then generates HTML/CSS. Why? I put it to you it's because **we don't think in HTML/CSS**. You CAN'T effectively think in HTML/CSS and if a guy who's expertise lies in designing user interfaces can't think in terms of HTML/CSS why the hell do we think we should?

**HTML was designed for linking documents** with a modicum of layout and has served that purpose admirably. As a result, the web browser largely won the battle for desktop supremacy and almost everyone has a web browser and regularly uses a number of web sites. Similarly, pretty much everyone has a computer running an 80x86 based CPU and run dozens of applications built specifically for it. **HTML/CSS are the machine language of the web**.

For those of us lucky enough to have done any assembler programming, we've also been lucky enough not to have had to do any for a very long time. Instead, we chose to move away from assembler to other languages. C, C++, Java, Smalltalk, Python, Perl, Ruby, literally **dozens of other programming languages that have systematically improved the level of abstraction.** Many of these languages now run on top of the JVM, LLVM, CLR, etc. themselves abstractions on top of the underlying CPU.

Did we move because the runtime was faster? Hardly. In fact in almost all cases outrageous claims were made early on that poor performance would be the undoing of these languages and in almost all cases these claims ultimately proved unfounded. No, **we moved to these languages because we hoped they would give us a better level of abstraction.** That we could code more closely to the way we think. That we would one day realise the dream of literally thinking in code.

Even within languages we constantly strive to improve the level of abstraction. In many cases we've created Domain-Specific-Languages in order that we are better able to think IN the language most appropriate to the task at hand rather than needing to perform some contorted mapping process. This is the reason the Ruby community has slowly moved from Test::Unit to RSpec/Shoulda: Test::Unit does the job just fine but it's verbose and "too close to the metal". Just like assembler. **When I'm the most productive I'm literally thinking in code.**

**We've largely sorted the back-end problems**: Database access layers, routing, data format conversion, validation, you name it it's all been largely worked out in whatever framework and language combination you can imagine. **The same cannot be said of the front-end WHERE IT ACTUALLY MATTERS.**

Granted, HTML/CSS has undergone change but to what extent and to what end? We have JSP, ASP, ERB, HAML, SASS, Liquid, blueprint, jQuery, Prototype, MooTools, Dojo, YUI, etc. but none of them appreciably raises the level of abstraction. **Most advances in the world of HTML/CSS are lipstick.** They're all constrained by the fallacy that HTML/CSS is the holy grail of web design. No, the whole problem with web development is that **we haven't abstracted away the underlying technology**, instead we've been conned by a bunch of HTML/CSS gurus and boffins who think that designing the perfect machine code is all the world needs. **There is nothing more primitive than HTML+CSS when it comes to the web.**

HTML & CSS try to be all things to all people and by doing so, much like J2EE, we ended up with a set of primitive tools that are repetitive, verbose, hard to test, maintain and refactor and ultimately provide a user experience that can best be described as **a tarted up, 24-bit 3270 terminal.** Don't believe me? Point me at a website where the user experience feels liquid and natural. Where it literally gets out of your way so that you never even realise you're using it? For the most part you can't. The poster children of the Rails world provide at best a rudimentary user experience. I suspect people use them because there is no alternative, not because it's actually a great UX. Why? IMHO because the technology choices are just plain awful. If you can find a website with a rich user experience that just melts away, you'll likely find a bunch of developers who either had nervous breakdowns or spent many years building some superduper framework, or both!

To be fair I'm no doubt coming across as though HTML/CSS is to blame for all the world's problems. Not at all. We suffer from similar problems across the board in software development. It just so happens that I've been in the world of web development for a long time now and feeling the effects.

I'm not advocating the use of any particular technology -- that would kinda defeat the purpose of my argument. What I am saying is that I believe we're stuck in a mindset that only allows us to think inside the incredibly narrow bounds of something we're used to, IMHO, only because it's all we're used to.

Rather than embracing the "web paradigm" how about we **embrace the user and their experience and decide what technology would best enable us to deliver that.**
